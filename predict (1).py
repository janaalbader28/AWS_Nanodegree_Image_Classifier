# -*- coding: utf-8 -*-
"""predict.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1it9jx8pUX6H1431_8ybPPOAKUZNB2V7T
"""

import argparse
import torch
from torchvision import models, transforms
from PIL import Image
import os
import json

# Parse command line arguments
def parse_args():
    parser = argparse.ArgumentParser(description='Predict an image using a trained neural network model')
    parser.add_argument('image_path', type=str, help='Path to the image to be classified')
    parser.add_argument('checkpoint_path', type=str, help='Path to the trained model checkpoint')
    parser.add_argument("--top_classes", type=int, default=1, help="Top K most likely classes.")
    parser.add_argument('--gpu', action='store_true', help="Use GPU for inference.")
    parser.add_argument('--category_names', type=str, help="Path to a JSON file mapping class indices to class names.")
    return parser.parse_args()

# Load the model checkpoint
def load_checkpoint(checkpoint_path):
    checkpoint = torch.load(checkpoint_path)
    model_name = checkpoint['architecture']
    model = None

    if model_name == 'vgg16':
        model = models.vgg16(pretrained=True)
    elif model_name == 'alexnet':
        model = models.alexnet(pretrained=True)
    else:
        raise ValueError(f"Unsupported model architecture")

    model.classifier = checkpoint['classifier']
    model.load_state_dict(checkpoint['state_dict'])
    model.class_to_idx = checkpoint['class_to_idx']
    return model

# Preprocess the input image
def process_image(image_path):
    image = Image.open(image_path)
    transform = transforms.Compose([
        transforms.Resize(255),
        transforms.CenterCrop(224),
        transforms.ToTensor(),
        transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])])

    image = transform(image)
    image = image.unsqueeze(0)

    return image

# Predict the class of the image
def predict(image_path, model, top_classes, device):
    model.to(device)
    model.eval()

    image = process_image(image_path)

    with torch.no_grad():
        image = image.to(device)
        outputs = model(image)

        probs, indices = torch.topk(outputs, top_classes, dim=1)
        probs = probs.squeeze().cpu().numpy()
        indices = indices.squeeze().cpu().numpy()

        # Convert indices to class labels
        idx_to_class = {value: key for key, value in model.class_to_idx.items()}
        class_labels = [idx_to_class[idx] for idx in indices]

        return class_labels, probs

# Load category names
def load_cat_names(category_names_path):
    with open(category_names_path, "r") as f:
        cat_to_name = json.load(f)
    return cat_to_name

# Main function
def main():
    args = parse_args()

    device = torch.device("cuda" if args.gpu and torch.cuda.is_available() else "cpu")

    # Load the model
    model = load_checkpoint(args.checkpoint_path)
    model.to(device)

    cat_to_name = None
    if args.category_names:
        cat_to_name = load_cat_names(args.category_names)

    # Predict the top K classes
    class_labels, probs = predict(args.image_path, model, args.top_classes, device)

    class_names = [cat_to_name[str(cls)] for cls in class_labels] if cat_to_name else class_labels

    # Print results
    for i in range(args.top_classes):
        print(f"Number: {i+1}/{args.top_classes}.. "
              f"Class name: {class_names[i]}.. "
              f"Probability: {probs[i]*100:.3f}%")

if __name__ == "__main__":
    main()